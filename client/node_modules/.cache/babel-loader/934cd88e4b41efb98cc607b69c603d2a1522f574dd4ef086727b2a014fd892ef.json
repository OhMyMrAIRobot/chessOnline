{"ast":null,"code":"import { Colors } from \"./Colors\";\nimport { FigureNames } from \"./figures/Figure\";\nexport class Cell {\n  constructor(board, x, y, color, figure) {\n    this._x = void 0;\n    this._y = void 0;\n    this._color = void 0;\n    this._figure = void 0;\n    this._board = void 0;\n    this._available = void 0;\n    this._id = void 0;\n    this._board = board;\n    this._x = x;\n    this._y = y;\n    this._color = color;\n    this._figure = figure;\n    this._available = false;\n    this._id = Math.random();\n  }\n  isEmpty() {\n    return this._figure === null;\n  }\n  isEnemy(target) {\n    if (target._figure) {\n      var _this$_figure;\n      return ((_this$_figure = this._figure) === null || _this$_figure === void 0 ? void 0 : _this$_figure._color) !== target._figure._color;\n    }\n    return false;\n  }\n  getKing(target, color) {\n    this._board._cells.map(row => {\n      row.forEach(cell => {});\n    });\n  }\n  isEmptyVertical(target) {\n    if (this._x !== target._x) return false;\n    const min = Math.min(this._y, target._y);\n    const max = Math.max(this._y, target._y);\n    for (let y = min + 1; y < max; y++) {\n      if (!this._board.getCell(this._x, y).isEmpty()) return false;\n    }\n    return true;\n  }\n  isEmptyHorizontal(target) {\n    if (this._y !== target._y) return false;\n    const min = Math.min(this._x, target._x);\n    const max = Math.max(this._x, target._x);\n    for (let x = min + 1; x < max; x++) {\n      if (!this._board.getCell(x, this._y).isEmpty()) return false;\n    }\n    return true;\n  }\n  isEmptyDiagonal(target) {\n    const absX = Math.abs(this._x - target._x);\n    const absY = Math.abs(this._y - target._y);\n    if (absX !== absY) return false;\n    const dy = this._y < target._y ? 1 : -1;\n    const dx = this._x < target._x ? 1 : -1;\n    for (let i = 1; i < absX; i++) {\n      if (!this._board.getCell(this._x + dx * i, this._y + dy * i).isEmpty()) return false;\n    }\n    return true;\n  }\n  isCellUnderAttack(target, color) {\n    for (const row of this._board._cells) {\n      for (const cell of row) {\n        const figure = cell._figure;\n        if (figure && figure._color !== color) {\n          if (figure._name === FigureNames.PAWN && figure.canPawnAttack(target)) {\n            return true;\n          }\n          const tmp = target._figure;\n          target._figure = null;\n          if (figure.canMove(target) && figure._name !== FigureNames.PAWN) {\n            target._figure = tmp;\n            return true;\n          }\n          target._figure = tmp;\n        }\n      }\n    }\n    return false;\n  }\n  setFigure(figure) {\n    this._figure = figure;\n    this._figure._cell = this;\n  }\n  addLostFigure(figure) {\n    figure._color === Colors.BLACK ? this._board._lostBlackFigures.push(figure) : this._board._lostWhiteFigures.push(figure);\n  }\n  moveFigure(targetCell) {\n    var _this$_figure2;\n    if (this._figure && (_this$_figure2 = this._figure) !== null && _this$_figure2 !== void 0 && _this$_figure2.canMove(targetCell)) {\n      this._figure.moveFigure(targetCell);\n      if (targetCell._figure) {\n        this.addLostFigure(targetCell._figure);\n      }\n      targetCell.setFigure(this._figure);\n      this._figure = null;\n    }\n  }\n}","map":{"version":3,"names":["Colors","FigureNames","Cell","constructor","board","x","y","color","figure","_x","_y","_color","_figure","_board","_available","_id","Math","random","isEmpty","isEnemy","target","_this$_figure","getKing","_cells","map","row","forEach","cell","isEmptyVertical","min","max","getCell","isEmptyHorizontal","isEmptyDiagonal","absX","abs","absY","dy","dx","i","isCellUnderAttack","_name","PAWN","canPawnAttack","tmp","canMove","setFigure","_cell","addLostFigure","BLACK","_lostBlackFigures","push","_lostWhiteFigures","moveFigure","targetCell","_this$_figure2"],"sources":["/Users/mrairobot/Desktop/main/ksis/Online_Chess/client/src/models/Cell.ts"],"sourcesContent":["import {Colors} from \"./Colors\";\nimport {Figure, FigureNames} from \"./figures/Figure\";\nimport {Board} from \"./Board\";\n\nexport class Cell{\n    readonly _x: number;\n    readonly _y: number;\n    readonly _color: Colors;\n    _figure: Figure | null;\n    _board: Board;\n    _available: boolean;\n    _id: number;\n\n    constructor(board: Board, x: number, y: number, color: Colors, figure: Figure | null) {\n        this._board = board;\n        this._x = x;\n        this._y = y;\n        this._color = color;\n        this._figure = figure;\n        this._available = false;\n        this._id = Math.random()\n    }\n\n    isEmpty(): boolean {\n        return this._figure === null;\n    }\n\n    isEnemy(target: Cell): boolean {\n        if (target._figure){\n            return this._figure?._color !== target._figure._color;\n        }\n        return false;\n    }\n\n    getKing(target: Cell, color: Colors): Cell{\n        this._board._cells.map(row => {\n            row.forEach(cell => {\n                \n            })\n        })\n    }\n\n    isEmptyVertical(target: Cell): boolean {\n        if (this._x !== target._x)\n            return false;\n\n        const min = Math.min(this._y, target._y);\n        const max = Math.max(this._y, target._y);\n\n        for (let y = min + 1; y < max; y++){\n            if (!this._board.getCell(this._x, y).isEmpty())\n                return false;\n        }\n        return true;\n    }\n\n    isEmptyHorizontal(target: Cell): boolean {\n        if (this._y !== target._y)\n            return false;\n\n        const min = Math.min(this._x, target._x);\n        const max = Math.max(this._x, target._x);\n\n        for (let x = min + 1; x < max; x++){\n            if (!this._board.getCell(x, this._y).isEmpty())\n                return false;\n        }\n\n        return true;\n    }\n\n    isEmptyDiagonal(target: Cell): boolean {\n        const absX = Math.abs(this._x - target._x);\n        const absY = Math.abs(this._y - target._y);\n        if (absX !== absY)\n            return false;\n\n        const dy = this._y < target._y ? 1 : -1;\n        const dx = this._x < target._x ? 1 : -1;\n\n        for (let i = 1; i < absX; i++){\n            if (!this._board.getCell(this._x + dx * i, this._y + dy * i).isEmpty())\n                return false;\n        }\n\n        return true;\n    }\n\n    public isCellUnderAttack(target: Cell, color: Colors | undefined): boolean {\n        for (const row of this._board._cells) {\n            for (const cell of row) {\n                const figure = cell._figure;\n                if (figure && figure._color !== color) {\n                    if (figure._name === FigureNames.PAWN && figure.canPawnAttack(target)) {\n                        return true;\n                    }\n                    const tmp = target._figure;\n                    target._figure = null;\n                    if (figure.canMove(target) && figure._name !== FigureNames.PAWN) {\n                        target._figure = tmp;\n                        return true;\n                    }\n                    target._figure = tmp;\n                }\n            }\n        }\n        return false;\n    }\n\n    setFigure(figure: Figure) {\n        this._figure = figure;\n        this._figure._cell = this;\n    }\n\n    addLostFigure(figure: Figure) {\n        figure._color === Colors.BLACK ?\n            this._board._lostBlackFigures.push(figure)\n            :\n            this._board._lostWhiteFigures.push(figure);\n    }\n\n    public moveFigure(targetCell: Cell) {\n        if (this._figure && this._figure?.canMove(targetCell)){\n            this._figure.moveFigure(targetCell);\n            if (targetCell._figure){\n                this.addLostFigure(targetCell._figure);\n            }\n            targetCell.setFigure(this._figure)\n            this._figure = null;\n        }\n    }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}