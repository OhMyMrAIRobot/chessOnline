{"ast":null,"code":"import { Colors } from \"./Colors\";\nimport { FigureNames } from \"./figures/Figure\";\nexport class Cell {\n  constructor(board, x, y, color, figure) {\n    this._x = void 0;\n    this._y = void 0;\n    this._color = void 0;\n    this._figure = void 0;\n    this._board = void 0;\n    this._available = void 0;\n    this._id = void 0;\n    this._board = board;\n    this._x = x;\n    this._y = y;\n    this._color = color;\n    this._figure = figure;\n    this._available = false;\n    this._id = Math.random();\n  }\n  isEmpty() {\n    return this._figure === null;\n  }\n  isEnemy(target) {\n    if (target._figure) {\n      var _this$_figure;\n      return ((_this$_figure = this._figure) === null || _this$_figure === void 0 ? void 0 : _this$_figure._color) !== target._figure._color;\n    }\n    return false;\n  }\n  getKing(color) {\n    this._board._cells.forEach(row => {\n      row.forEach(cell => {\n        var _cell$_figure;\n        if (((_cell$_figure = cell._figure) === null || _cell$_figure === void 0 ? void 0 : _cell$_figure._name) === FigureNames.KING && cell._figure._color === color) {\n          return cell;\n        }\n      });\n    });\n    return new Cell(this._board, 0, 0, Colors.BLACK, null);\n  }\n  isEmptyVertical(target) {\n    if (this._x !== target._x) return false;\n    const min = Math.min(this._y, target._y);\n    const max = Math.max(this._y, target._y);\n    for (let y = min + 1; y < max; y++) {\n      if (!this._board.getCell(this._x, y).isEmpty()) return false;\n    }\n    return true;\n  }\n  isEmptyHorizontal(target) {\n    if (this._y !== target._y) return false;\n    const min = Math.min(this._x, target._x);\n    const max = Math.max(this._x, target._x);\n    for (let x = min + 1; x < max; x++) {\n      if (!this._board.getCell(x, this._y).isEmpty()) return false;\n    }\n    return true;\n  }\n  isEmptyDiagonal(target) {\n    const absX = Math.abs(this._x - target._x);\n    const absY = Math.abs(this._y - target._y);\n    if (absX !== absY) return false;\n    const dy = this._y < target._y ? 1 : -1;\n    const dx = this._x < target._x ? 1 : -1;\n    for (let i = 1; i < absX; i++) {\n      if (!this._board.getCell(this._x + dx * i, this._y + dy * i).isEmpty()) return false;\n    }\n    return true;\n  }\n  isCellUnderAttack(target, color) {\n    for (const row of this._board._cells) {\n      for (const cell of row) {\n        const figure = cell._figure;\n        if (figure && figure._color !== color) {\n          if (figure._name === FigureNames.PAWN && figure.canPawnAttack(target)) {\n            return true;\n          }\n          const tmp = target._figure;\n          target._figure = null;\n          if (figure.canMove(target) && figure._name !== FigureNames.PAWN) {\n            target._figure = tmp;\n            return true;\n          }\n          target._figure = tmp;\n        }\n      }\n    }\n    return false;\n  }\n  setFigure(figure) {\n    this._figure = figure;\n    this._figure._cell = this;\n  }\n  addLostFigure(figure) {\n    figure._color === Colors.BLACK ? this._board._lostBlackFigures.push(figure) : this._board._lostWhiteFigures.push(figure);\n  }\n  moveFigure(targetCell) {\n    var _this$_figure2;\n    if (this._figure && (_this$_figure2 = this._figure) !== null && _this$_figure2 !== void 0 && _this$_figure2.canMove(targetCell)) {\n      this._figure.moveFigure(targetCell);\n      if (targetCell._figure) {\n        this.addLostFigure(targetCell._figure);\n      }\n      targetCell.setFigure(this._figure);\n      this._figure = null;\n    }\n  }\n}","map":{"version":3,"names":["Colors","FigureNames","Cell","constructor","board","x","y","color","figure","_x","_y","_color","_figure","_board","_available","_id","Math","random","isEmpty","isEnemy","target","_this$_figure","getKing","_cells","forEach","row","cell","_cell$_figure","_name","KING","BLACK","isEmptyVertical","min","max","getCell","isEmptyHorizontal","isEmptyDiagonal","absX","abs","absY","dy","dx","i","isCellUnderAttack","PAWN","canPawnAttack","tmp","canMove","setFigure","_cell","addLostFigure","_lostBlackFigures","push","_lostWhiteFigures","moveFigure","targetCell","_this$_figure2"],"sources":["/Users/mrairobot/Desktop/main/ksis/Online_Chess/client/src/models/Cell.ts"],"sourcesContent":["import {Colors} from \"./Colors\";\nimport {Figure, FigureNames} from \"./figures/Figure\";\nimport {Board} from \"./Board\";\n\nexport class Cell{\n    readonly _x: number;\n    readonly _y: number;\n    readonly _color: Colors;\n    _figure: Figure | null;\n    _board: Board;\n    _available: boolean;\n    _id: number;\n\n    constructor(board: Board, x: number, y: number, color: Colors, figure: Figure | null) {\n        this._board = board;\n        this._x = x;\n        this._y = y;\n        this._color = color;\n        this._figure = figure;\n        this._available = false;\n        this._id = Math.random()\n    }\n\n    isEmpty(): boolean {\n        return this._figure === null;\n    }\n\n    isEnemy(target: Cell): boolean {\n        if (target._figure){\n            return this._figure?._color !== target._figure._color;\n        }\n        return false;\n    }\n\n    getKing(color: Colors): Cell {\n        this._board._cells.forEach((row) => {\n            row.forEach((cell) => {\n                if (cell._figure?._name === FigureNames.KING && cell._figure._color === color){\n                    return cell;\n                }\n\n            })\n        })\n        return new Cell(this._board, 0, 0, Colors.BLACK, null)\n    }\n\n    isEmptyVertical(target: Cell): boolean {\n        if (this._x !== target._x)\n            return false;\n\n        const min = Math.min(this._y, target._y);\n        const max = Math.max(this._y, target._y);\n\n        for (let y = min + 1; y < max; y++){\n            if (!this._board.getCell(this._x, y).isEmpty())\n                return false;\n        }\n        return true;\n    }\n\n    isEmptyHorizontal(target: Cell): boolean {\n        if (this._y !== target._y)\n            return false;\n\n        const min = Math.min(this._x, target._x);\n        const max = Math.max(this._x, target._x);\n\n        for (let x = min + 1; x < max; x++){\n            if (!this._board.getCell(x, this._y).isEmpty())\n                return false;\n        }\n\n        return true;\n    }\n\n    isEmptyDiagonal(target: Cell): boolean {\n        const absX = Math.abs(this._x - target._x);\n        const absY = Math.abs(this._y - target._y);\n        if (absX !== absY)\n            return false;\n\n        const dy = this._y < target._y ? 1 : -1;\n        const dx = this._x < target._x ? 1 : -1;\n\n        for (let i = 1; i < absX; i++){\n            if (!this._board.getCell(this._x + dx * i, this._y + dy * i).isEmpty())\n                return false;\n        }\n\n        return true;\n    }\n\n    public isCellUnderAttack(target: Cell, color: Colors): boolean {\n        for (const row of this._board._cells) {\n            for (const cell of row) {\n                const figure = cell._figure;\n                if (figure && figure._color !== color) {\n                    if (figure._name === FigureNames.PAWN && figure.canPawnAttack(target)) {\n                        return true;\n                    }\n                    const tmp = target._figure;\n                    target._figure = null;\n                    if (figure.canMove(target) && figure._name !== FigureNames.PAWN) {\n                        target._figure = tmp;\n                        return true;\n                    }\n                    target._figure = tmp;\n                }\n            }\n        }\n        return false;\n    }\n\n    setFigure(figure: Figure) {\n        this._figure = figure;\n        this._figure._cell = this;\n    }\n\n    addLostFigure(figure: Figure) {\n        figure._color === Colors.BLACK ?\n            this._board._lostBlackFigures.push(figure)\n            :\n            this._board._lostWhiteFigures.push(figure);\n    }\n\n    public moveFigure(targetCell: Cell) {\n        if (this._figure && this._figure?.canMove(targetCell)){\n            this._figure.moveFigure(targetCell);\n            if (targetCell._figure){\n                this.addLostFigure(targetCell._figure);\n            }\n            targetCell.setFigure(this._figure)\n            this._figure = null;\n        }\n    }\n}"],"mappings":"AAAA,SAAQA,MAAM,QAAO,UAAU;AAC/B,SAAgBC,WAAW,QAAO,kBAAkB;AAGpD,OAAO,MAAMC,IAAI;EASbC,WAAWA,CAACC,KAAY,EAAEC,CAAS,EAAEC,CAAS,EAAEC,KAAa,EAAEC,MAAqB,EAAE;IAAA,KAR7EC,EAAE;IAAA,KACFC,EAAE;IAAA,KACFC,MAAM;IAAA,KACfC,OAAO;IAAA,KACPC,MAAM;IAAA,KACNC,UAAU;IAAA,KACVC,GAAG;IAGC,IAAI,CAACF,MAAM,GAAGT,KAAK;IACnB,IAAI,CAACK,EAAE,GAAGJ,CAAC;IACX,IAAI,CAACK,EAAE,GAAGJ,CAAC;IACX,IAAI,CAACK,MAAM,GAAGJ,KAAK;IACnB,IAAI,CAACK,OAAO,GAAGJ,MAAM;IACrB,IAAI,CAACM,UAAU,GAAG,KAAK;IACvB,IAAI,CAACC,GAAG,GAAGC,IAAI,CAACC,MAAM,CAAC,CAAC;EAC5B;EAEAC,OAAOA,CAAA,EAAY;IACf,OAAO,IAAI,CAACN,OAAO,KAAK,IAAI;EAChC;EAEAO,OAAOA,CAACC,MAAY,EAAW;IAC3B,IAAIA,MAAM,CAACR,OAAO,EAAC;MAAA,IAAAS,aAAA;MACf,OAAO,EAAAA,aAAA,OAAI,CAACT,OAAO,cAAAS,aAAA,uBAAZA,aAAA,CAAcV,MAAM,MAAKS,MAAM,CAACR,OAAO,CAACD,MAAM;IACzD;IACA,OAAO,KAAK;EAChB;EAEAW,OAAOA,CAACf,KAAa,EAAQ;IACzB,IAAI,CAACM,MAAM,CAACU,MAAM,CAACC,OAAO,CAAEC,GAAG,IAAK;MAChCA,GAAG,CAACD,OAAO,CAAEE,IAAI,IAAK;QAAA,IAAAC,aAAA;QAClB,IAAI,EAAAA,aAAA,GAAAD,IAAI,CAACd,OAAO,cAAAe,aAAA,uBAAZA,aAAA,CAAcC,KAAK,MAAK3B,WAAW,CAAC4B,IAAI,IAAIH,IAAI,CAACd,OAAO,CAACD,MAAM,KAAKJ,KAAK,EAAC;UAC1E,OAAOmB,IAAI;QACf;MAEJ,CAAC,CAAC;IACN,CAAC,CAAC;IACF,OAAO,IAAIxB,IAAI,CAAC,IAAI,CAACW,MAAM,EAAE,CAAC,EAAE,CAAC,EAAEb,MAAM,CAAC8B,KAAK,EAAE,IAAI,CAAC;EAC1D;EAEAC,eAAeA,CAACX,MAAY,EAAW;IACnC,IAAI,IAAI,CAACX,EAAE,KAAKW,MAAM,CAACX,EAAE,EACrB,OAAO,KAAK;IAEhB,MAAMuB,GAAG,GAAGhB,IAAI,CAACgB,GAAG,CAAC,IAAI,CAACtB,EAAE,EAAEU,MAAM,CAACV,EAAE,CAAC;IACxC,MAAMuB,GAAG,GAAGjB,IAAI,CAACiB,GAAG,CAAC,IAAI,CAACvB,EAAE,EAAEU,MAAM,CAACV,EAAE,CAAC;IAExC,KAAK,IAAIJ,CAAC,GAAG0B,GAAG,GAAG,CAAC,EAAE1B,CAAC,GAAG2B,GAAG,EAAE3B,CAAC,EAAE,EAAC;MAC/B,IAAI,CAAC,IAAI,CAACO,MAAM,CAACqB,OAAO,CAAC,IAAI,CAACzB,EAAE,EAAEH,CAAC,CAAC,CAACY,OAAO,CAAC,CAAC,EAC1C,OAAO,KAAK;IACpB;IACA,OAAO,IAAI;EACf;EAEAiB,iBAAiBA,CAACf,MAAY,EAAW;IACrC,IAAI,IAAI,CAACV,EAAE,KAAKU,MAAM,CAACV,EAAE,EACrB,OAAO,KAAK;IAEhB,MAAMsB,GAAG,GAAGhB,IAAI,CAACgB,GAAG,CAAC,IAAI,CAACvB,EAAE,EAAEW,MAAM,CAACX,EAAE,CAAC;IACxC,MAAMwB,GAAG,GAAGjB,IAAI,CAACiB,GAAG,CAAC,IAAI,CAACxB,EAAE,EAAEW,MAAM,CAACX,EAAE,CAAC;IAExC,KAAK,IAAIJ,CAAC,GAAG2B,GAAG,GAAG,CAAC,EAAE3B,CAAC,GAAG4B,GAAG,EAAE5B,CAAC,EAAE,EAAC;MAC/B,IAAI,CAAC,IAAI,CAACQ,MAAM,CAACqB,OAAO,CAAC7B,CAAC,EAAE,IAAI,CAACK,EAAE,CAAC,CAACQ,OAAO,CAAC,CAAC,EAC1C,OAAO,KAAK;IACpB;IAEA,OAAO,IAAI;EACf;EAEAkB,eAAeA,CAAChB,MAAY,EAAW;IACnC,MAAMiB,IAAI,GAAGrB,IAAI,CAACsB,GAAG,CAAC,IAAI,CAAC7B,EAAE,GAAGW,MAAM,CAACX,EAAE,CAAC;IAC1C,MAAM8B,IAAI,GAAGvB,IAAI,CAACsB,GAAG,CAAC,IAAI,CAAC5B,EAAE,GAAGU,MAAM,CAACV,EAAE,CAAC;IAC1C,IAAI2B,IAAI,KAAKE,IAAI,EACb,OAAO,KAAK;IAEhB,MAAMC,EAAE,GAAG,IAAI,CAAC9B,EAAE,GAAGU,MAAM,CAACV,EAAE,GAAG,CAAC,GAAG,CAAC,CAAC;IACvC,MAAM+B,EAAE,GAAG,IAAI,CAAChC,EAAE,GAAGW,MAAM,CAACX,EAAE,GAAG,CAAC,GAAG,CAAC,CAAC;IAEvC,KAAK,IAAIiC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGL,IAAI,EAAEK,CAAC,EAAE,EAAC;MAC1B,IAAI,CAAC,IAAI,CAAC7B,MAAM,CAACqB,OAAO,CAAC,IAAI,CAACzB,EAAE,GAAGgC,EAAE,GAAGC,CAAC,EAAE,IAAI,CAAChC,EAAE,GAAG8B,EAAE,GAAGE,CAAC,CAAC,CAACxB,OAAO,CAAC,CAAC,EAClE,OAAO,KAAK;IACpB;IAEA,OAAO,IAAI;EACf;EAEOyB,iBAAiBA,CAACvB,MAAY,EAAEb,KAAa,EAAW;IAC3D,KAAK,MAAMkB,GAAG,IAAI,IAAI,CAACZ,MAAM,CAACU,MAAM,EAAE;MAClC,KAAK,MAAMG,IAAI,IAAID,GAAG,EAAE;QACpB,MAAMjB,MAAM,GAAGkB,IAAI,CAACd,OAAO;QAC3B,IAAIJ,MAAM,IAAIA,MAAM,CAACG,MAAM,KAAKJ,KAAK,EAAE;UACnC,IAAIC,MAAM,CAACoB,KAAK,KAAK3B,WAAW,CAAC2C,IAAI,IAAIpC,MAAM,CAACqC,aAAa,CAACzB,MAAM,CAAC,EAAE;YACnE,OAAO,IAAI;UACf;UACA,MAAM0B,GAAG,GAAG1B,MAAM,CAACR,OAAO;UAC1BQ,MAAM,CAACR,OAAO,GAAG,IAAI;UACrB,IAAIJ,MAAM,CAACuC,OAAO,CAAC3B,MAAM,CAAC,IAAIZ,MAAM,CAACoB,KAAK,KAAK3B,WAAW,CAAC2C,IAAI,EAAE;YAC7DxB,MAAM,CAACR,OAAO,GAAGkC,GAAG;YACpB,OAAO,IAAI;UACf;UACA1B,MAAM,CAACR,OAAO,GAAGkC,GAAG;QACxB;MACJ;IACJ;IACA,OAAO,KAAK;EAChB;EAEAE,SAASA,CAACxC,MAAc,EAAE;IACtB,IAAI,CAACI,OAAO,GAAGJ,MAAM;IACrB,IAAI,CAACI,OAAO,CAACqC,KAAK,GAAG,IAAI;EAC7B;EAEAC,aAAaA,CAAC1C,MAAc,EAAE;IAC1BA,MAAM,CAACG,MAAM,KAAKX,MAAM,CAAC8B,KAAK,GAC1B,IAAI,CAACjB,MAAM,CAACsC,iBAAiB,CAACC,IAAI,CAAC5C,MAAM,CAAC,GAE1C,IAAI,CAACK,MAAM,CAACwC,iBAAiB,CAACD,IAAI,CAAC5C,MAAM,CAAC;EAClD;EAEO8C,UAAUA,CAACC,UAAgB,EAAE;IAAA,IAAAC,cAAA;IAChC,IAAI,IAAI,CAAC5C,OAAO,KAAA4C,cAAA,GAAI,IAAI,CAAC5C,OAAO,cAAA4C,cAAA,eAAZA,cAAA,CAAcT,OAAO,CAACQ,UAAU,CAAC,EAAC;MAClD,IAAI,CAAC3C,OAAO,CAAC0C,UAAU,CAACC,UAAU,CAAC;MACnC,IAAIA,UAAU,CAAC3C,OAAO,EAAC;QACnB,IAAI,CAACsC,aAAa,CAACK,UAAU,CAAC3C,OAAO,CAAC;MAC1C;MACA2C,UAAU,CAACP,SAAS,CAAC,IAAI,CAACpC,OAAO,CAAC;MAClC,IAAI,CAACA,OAAO,GAAG,IAAI;IACvB;EACJ;AACJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}