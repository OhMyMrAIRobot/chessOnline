{"ast":null,"code":"import { Colors } from \"../Colors\";\nexport let FigureNames = /*#__PURE__*/function (FigureNames) {\n  FigureNames[\"FIGURE\"] = \"\\u0424\\u0438\\u0433\\u0443\\u0440\\u0430\";\n  FigureNames[\"KING\"] = \"\\u041A\\u043E\\u0440\\u043E\\u043B\\u044C\";\n  FigureNames[\"QUEEN\"] = \"\\u0424\\u0435\\u0440\\u0437\\u044C\";\n  FigureNames[\"KNIGHT\"] = \"\\u041A\\u043E\\u043D\\u044C\";\n  FigureNames[\"PAWN\"] = \"\\u041F\\u0435\\u0448\\u043A\\u0430\";\n  FigureNames[\"ROOK\"] = \"\\u041B\\u0430\\u0434\\u044C\\u044F\";\n  FigureNames[\"BISHOP\"] = \"\\u0421\\u043B\\u043E\\u043D\";\n  return FigureNames;\n}({});\nexport class Figure {\n  constructor(color, cell) {\n    this._color = void 0;\n    this._img = void 0;\n    this._cell = void 0;\n    this._name = void 0;\n    this._id = void 0;\n    this._color = color;\n    this._cell = cell;\n    this._cell._figure = this;\n    this._img = null;\n    this._name = FigureNames.FIGURE;\n    this._id = Math.random();\n  }\n  canAttack(target) {\n    var _target$_figure;\n    if (((_target$_figure = target._figure) === null || _target$_figure === void 0 ? void 0 : _target$_figure._color) === this._color)\n      // same color\n      return false;\n    return true;\n  }\n  canMove(target) {\n    var _target$_figure2;\n    if (((_target$_figure2 = target._figure) === null || _target$_figure2 === void 0 ? void 0 : _target$_figure2._color) === this._color)\n      // same color\n      return false;\n    const opponentColor = this._color === Colors.WHITE ? Colors.BLACK : Colors.WHITE;\n    for (const row of this._cell._board._cells) {\n      for (const cell of row) {\n        const figure = cell._figure;\n        if (figure && figure._color === opponentColor && figure._name === FigureNames.PAWN) {\n          if (figure.canPawnAttack(target)) {\n            return false;\n          }\n        }\n      }\n    }\n    for (const row of this._cell._board._cells) {\n      for (const cell of row) {\n        const figure = cell._figure;\n        if (figure && figure._color === opponentColor && figure._name !== FigureNames.PAWN) {\n          const tmp = target._figure;\n          target._figure = null;\n          if (figure.canMove(target)) {\n            target._figure = tmp;\n            return false;\n          }\n          target._figure = tmp;\n        }\n      }\n    }\n    return true;\n  }\n  canPawnAttack(target) {\n    var _this$_cell$_figure;\n    const direction = ((_this$_cell$_figure = this._cell._figure) === null || _this$_cell$_figure === void 0 ? void 0 : _this$_cell$_figure._color) === Colors.BLACK ? 1 : -1;\n    return target._y === this._cell._y + direction && (target._x === this._cell._x + 1 || target._x === this._cell._x - 1);\n  }\n  moveFigure(target) {}\n}","map":{"version":3,"names":["Colors","FigureNames","Figure","constructor","color","cell","_color","_img","_cell","_name","_id","_figure","FIGURE","Math","random","canAttack","target","_target$_figure","canMove","_target$_figure2","opponentColor","WHITE","BLACK","row","_board","_cells","figure","PAWN","canPawnAttack","tmp","_this$_cell$_figure","direction","_y","_x","moveFigure"],"sources":["/Users/mrairobot/Desktop/main/ksis/Online_Chess/client/src/models/figures/Figure.ts"],"sourcesContent":["import {Colors} from \"../Colors\";\nimport {Cell} from \"../Cell\";\nimport img from \"../../resourses/images/black-knight.png\"\n\nexport enum FigureNames{\n    FIGURE = \"Фигура\",\n    KING = \"Король\",\n    QUEEN= \"Ферзь\",\n    KNIGHT = \"Конь\",\n    PAWN = \"Пешка\",\n    ROOK = \"Ладья\",\n    BISHOP = \"Слон\",\n}\n\nexport class Figure{\n    _color: Colors;\n    _img: typeof img | null;\n    _cell: Cell;\n    _name: FigureNames;\n    _id: number;\n\n    constructor(color: Colors, cell: Cell) {\n        this._color = color;\n        this._cell = cell;\n        this._cell._figure = this;\n        this._img = null;\n        this._name = FigureNames.FIGURE;\n        this._id = Math.random();\n    }\n\n    canAttack(target: Cell): boolean {\n        if (target._figure?._color === this._color) // same color\n            return false;\n        return true;\n    }\n\n    canMove(target: Cell) : boolean {\n        if (target._figure?._color === this._color) // same color\n            return false;\n\n        const opponentColor: Colors = (this._color === Colors.WHITE) ? Colors.BLACK : Colors.WHITE;\n\n        for (const row of this._cell._board._cells) {\n            for (const cell of row) {\n                const figure = cell._figure;\n                if (figure && figure._color === opponentColor && figure._name === FigureNames.PAWN) {\n                    if (figure.canPawnAttack(target)) {\n                        return false;\n                    }\n                }\n            }\n        }\n        \n        for (const row of this._cell._board._cells) {\n            for (const cell of row) {\n                const figure = cell._figure;\n                if (figure && figure._color === opponentColor && figure._name !== FigureNames.PAWN) {\n                    const tmp = target._figure;\n                    target._figure = null;\n                    if (figure.canMove(target)) {\n                        target._figure = tmp;\n                        return false;\n                    }\n                    target._figure = tmp;\n                }\n            }\n        }\n\n        return true\n    }\n\n    canPawnAttack(target: Cell): boolean {\n        const direction = this._cell._figure?._color === Colors.BLACK ? 1 : -1;\n        return target._y === this._cell._y + direction\n            && (target._x === this._cell._x + 1 || target._x === this._cell._x - 1);\n    }\n\n    moveFigure(target: Cell){}\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}